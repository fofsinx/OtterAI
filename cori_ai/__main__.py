"""Main entry point for cori_ai."""
import asyncio
import logging
import sys
from typing import List, Dict, Any
import json
import os
import re

from cori_ai.core.config import settings
from cori_ai.github import GitHubClient
from cori_ai.review import CodeReviewer
from cori_ai.fix import FixGenerator


async def create_fix_pr(
    github: GitHubClient,
    owner: str,
    repo: str,
    number: int,
    fixes: List[Dict[str, Any]],
) -> None:
    """Create a pull request with fixes.
    
    Args:
        github: GitHub client instance.
        owner: Repository owner.
        repo: Repository name.
        number: Original PR number.
        fixes: List of fixes to apply.
    """
    # Get PR info
    pr = await github.get_pull_request(owner, repo, number)
    
    # Create branch name
    branch_name = f"otterai/fixes-for-pr-{number}"
    
    # Create branch from base
    await github.create_branch(
        owner=owner,
        repo=repo,
        branch=branch_name,
        sha=pr.head_sha,
    )
    
    # Create commits with fixes
    for fix in fixes:
        await github.create_commit(
            owner=owner,
            repo=repo,
            branch=branch_name,
            message=f"ðŸ¤– Fix: {fix['file']}",
            changes=[{
                "file": fix["file"],
                "content": fix["content"],
            }],
        )
    
    # Create PR
    await github.create_pull_request(
        owner=owner,
        repo=repo,
        title=f"ðŸ¤– OtterAI: Fixes for PR #{number}",
        body=f"""This PR contains automated fixes for issues found in #{number}.

Original PR: #{number}
Original title: {pr.title}

Changes made:
{json.dumps([fix["file"] for fix in fixes], indent=2)}

Please review the changes and merge if they look good.
You can also cherry-pick specific fixes into your original PR.

Generated by [OtterAI](https://github.com/harshgoswami/otterai)""",
        head=branch_name,
        base=pr.base_ref,
    )


async def main() -> int:
    """Main entry point.
    
    Returns:
        Exit code (0 for success, non-zero for failure).
    """
    # Configure logging
    logging.basicConfig(
        level=settings.log_level,
        format=settings.log_format,
    )
    logger = logging.getLogger(__name__)

    try:
        # Get environment variables
        owner = os.environ["GITHUB_REPOSITORY_OWNER"]
        repo = os.environ["GITHUB_REPOSITORY"].split("/")[1]
        pr_number = int(os.environ["INPUT_PR_NUMBER"])
        
        # Initialize clients
        async with GitHubClient() as github:
            reviewer = CodeReviewer(github)
            fix_generator = FixGenerator(github)
            
            # Review PR
            all_comments: List[Dict[str, Any]] = []
            try:
                async for review in reviewer.review_pull_request(owner, repo, pr_number):
                    # Create review comments
                    for comment in review.comments:
                        try:
                            created = await github.create_review_comment(
                                owner=owner,
                                repo=repo,
                                number=pr_number,
                                body=comment.body,
                                commit_id=os.environ["GITHUB_SHA"],
                                path=comment.path,
                                line=comment.line,
                            )
                            all_comments.append(created)
                        except Exception as e:
                            logger.error(f"Failed to create comment: {str(e)}")
                            
                    # Delete old comments if specified
                    for comment_id in review.comments_to_delete:
                        try:
                            await github.delete_review_comment(
                                owner=owner,
                                repo=repo,
                                comment_id=comment_id,
                            )
                        except Exception as e:
                            logger.error(f"Failed to delete comment: {str(e)}")
            except Exception as e:
                logger.error(f"Review failed: {str(e)}")
                return 1
            
            # Generate and apply fixes if needed
            if all_comments and not settings.skip_fixes:
                try:
                    fixes = []
                    async for fix in fix_generator.generate_fixes(
                        owner=owner,
                        repo=repo,
                        number=pr_number,
                        comments=all_comments,
                    ):
                        fixes.append(fix.dict())
                        logger.info(f"Generated fix for {fix.file}")
                    
                    if fixes:
                        await create_fix_pr(github, owner, repo, pr_number, fixes)
                        logger.info("Created PR with fixes")
                except Exception as e:
                    logger.error(f"Fix generation failed: {str(e)}")
                    # Don't fail the action if fix generation fails
        
        return 0
        
    except Exception as e:
        logger.error(f"Action failed: {str(e)}")
        return 1


if __name__ == "__main__":
    sys.exit(asyncio.run(main()))
